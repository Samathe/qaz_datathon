<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Индекс качества жизни – Казахстан (прототип)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<style>
  :root {
    --panel-bg: #ffffff;
    --bg: #f9fafb;
    --border: #d1d5db;
    --gridline: rgba(0,160,200,0.15);
    --text-main: #374151;
    --text-dim: #9ca3af;
    --radius-lg: 8px;
    --shadow-card: 0 10px 30px rgba(0,0,0,0.07);
    --shadow-float: 0 20px 60px rgba(0,0,0,0.18);
    --font: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
            "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
    --viz-height: 700px;
    --viz-width: 1400px;
  }

  body {
    margin: 0;
    background: var(--bg);
    font-family: var(--font);
    color: var(--text-main);
    line-height: 1.4;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .content-wrapper {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: center;
    width: 100%;
    max-width: 1700px;
    padding: 16px;
    box-sizing: border-box;
    gap: 16px;
  }

  .sidebar {
    width: 280px;
    min-width: 260px;
    max-width: 320px;
    background: var(--panel-bg);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-card);
    box-sizing: border-box;
    padding: 16px 16px 12px;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    height: var(--viz-height);
    position: sticky;
    top: 16px;
    flex-shrink: 0;
  }

  .sidebar-title {
    font-size: 15px;
    font-weight: 600;
    color: var(--text-main);
    margin-bottom: 4px;
  }

  .sidebar-sub {
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .slider-block {
    margin-bottom: 14px;
  }

  .slider-head {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    font-size: 13px;
    line-height: 1.2;
    font-weight: 500;
    color: var(--text-main);
    margin-bottom: 4px;
  }

  .slider-head .val {
    font-size: 12px;
    color: var(--text-dim);
    font-weight: 400;
    margin-left: 8px;
  }

  .slider-desc {
    font-size: 11px;
    color: var(--text-dim);
    line-height: 1.4;
    margin-bottom: 4px;
  }

  input[type=range] {
    width: 100%;
  }

  .group-block, .sort-block {
    font-size: 12px;
    color: var(--text-main);
    line-height: 1.4;
    margin-top: 16px;
    border-top: 1px solid var(--border);
    padding-top: 12px;
  }

  .block-label {
    margin-bottom: 4px;
    font-weight: 500;
    font-size: 12px;
    color: var(--text-main);
  }

  .select-wrapper {
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 6px 8px;
    font-size: 12px;
    background: #f9fafb;
    display: flex;
    flex-direction: row;
    align-items: center;
  }

  select {
    width: 100%;
    font-size: 12px;
    color: var(--text-main);
    background: transparent;
    border: none;
    outline: none;
  }

  .main-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    box-sizing: border-box;
    position: relative;
    max-width: var(--viz-width);
    width: 100%;
  }

  #viewTitle {
    margin: 6px 0 12px 0;
    font-size: 16px;
    color: var(--text-main);
    text-align: center;
    width: 100%;
  }

  svg {
    overflow: visible;
    font-family: var(--font);
    width: var(--viz-width);
    height: var(--viz-height);
    display: block;
  }

  .axis-line {
    stroke: var(--gridline);
    stroke-width: 1;
  }

  .stem-label {
    fill: var(--text-main);
    font-size: 22px;
    font-weight: 600;
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
  }

  .score-text {
    font-size: 20px;
    font-weight: 700;
    fill: #374151;
    text-anchor: middle;
    alignment-baseline: middle;
    pointer-events: none;
  }

  .flower-group {
    cursor: pointer;
    transition: opacity 0.15s;
  }

  .petal {
    fill-opacity: 0.9;
    stroke: rgba(0,0,0,0.15);
    stroke-width: 0.4px;
    pointer-events: none;
  }

  .flower-group.highlight .petal {
    stroke-width: 0.8px;
    stroke: rgba(0,0,0,0.4);
  }

  .hit-area {
    fill: transparent;
    pointer-events: all;
  }

  .detail-card {
    position: fixed;
    min-width: 340px;
    max-width: 400px;
    background: #ffffff;
    border: 1px solid var(--border);
    border-radius: 4px;
    box-shadow: var(--shadow-float);
    padding: 16px 20px 16px;
    font-size: 12px;
    color: var(--text-main);
    line-height: 1.4;
    z-index: 9999;
    display: none;
    pointer-events: none;
  }

  .detail-header {
    font-weight: 600;
    font-size: 14px;
    color: var(--text-main);
    margin-bottom: 8px;
    border-bottom: 1px solid var(--border);
    padding-bottom: 4px;
  }

  .scale-row {
    font-size: 10px;
    color: var(--text-main);
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
    display: flex;
    justify-content: flex-end;
    column-gap: 3px;
    margin-bottom: 8px;
  }

  .bar-row {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    font-size: 12px;
    line-height: 1.2;
  }

  .bar-label {
    flex: 1;
    padding-right: 6px;
    white-space: nowrap;
  }

  .bar-wrapper {
    display: flex;
    flex-direction: row;
    align-items: center;
    column-gap: 6px;
    min-width: 160px;
  }

  .bar-track {
    width: 120px;
    height: 10px;
    border-radius: 2px;
    background: #eee;
    position: relative;
    flex-shrink: 0;
  }

  .bar-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 10px;
    border-radius: 2px;
  }

  .bar-value {
    font-size: 11px;
    color: var(--text-main);
    min-width: 24px;
    text-align: left;
    font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", monospace;
  }

  .detail-extra {
    font-size: 11px;
    color: var(--text-dim);
    margin-top: 10px;
    line-height: 1.4;
    border-top: 1px solid var(--border);
    padding-top: 8px;
  }
</style>
</head>
<body>
<div class="content-wrapper">
  <aside class="sidebar">
    <div class="sidebar-title">Создайте свой Индекс Качества Жизни</div>
    <div class="sidebar-sub">
      Лепестки = показатели качества жизни (жильё, доход, здоровье...).
      Высота цветка = итоговый индекс, учитывающий ваши веса.
    </div>

    <div id="sliders"></div>

    <div class="group-block">
    <div class="block-label">Сравнивать по (ось X):</div>
    <div class="select-wrapper">
      <select id="groupSelect">
        <option value="Region">Регион (область / город)</option>
        <option value="AgeGroup">Возрастная группа</option>
        <option value="Gender">Гендер</option>
        <option value="SettlementType">Тип поселения</option>
        <option value="Year">Год</option>
      </select>
    </div>
    <div style="font-size:11px;color:var(--text-dim);margin-top:6px;">
      Это то, как мы делим население: регионы, возраст, пол, город/село или год.
    </div>
  </div>

  <div class="sort-block">
    <div class="block-label">Сортировать по:</div>
    <div class="select-wrapper">
      <select id="sortSelect">
        <option value="name">Название (А–Я)</option>
        <option value="score_desc">Индекс (высокий → низкий)</option>
        <option value="score_asc">Индекс (низкий → высокий)</option>
      </select>
    </div>
    </div>
  </aside>

  <section class="main-area">
    <h2 id="viewTitle"></h2>
    <svg id="viz"></svg>
    <div class="detail-card" id="detailCard"></div>
  </section>
</div>

<script>
const DIMENSIONS = [
  { key: "food_insecurity", label: "Food Insecurity" },
  { key: "missed_payments", label: "Missed Payments Rate" },
  { key: "internet_access", label: "Internet Access Rate" },
  { key: "unmet_healthcare", label: "Unmet Healthcare Need" },
  { key: "clothing_afford", label: "Basic Clothing Affordability" },
  { key: "internet_use", label: "Regular Internet Use" },
  { key: "social_afford", label: "Social Affordability" },
  { key: "holiday_afford", label: "Holiday Affordability" },
  { key: "welfare_trend", label: "Welfare Trend Distribution" },
  { key: "health_index", label: "Health Index" },
  { key: "housing_quality", label: "Housing Quality Index" },
  { key: "leisure_time", label: "Leisure Time Index" },
  { key: "life_index", label: "Life Index" },
  { key: "living_condition", label: "Living Condition Index" },
  { key: "prof_wellbeing", label: "Professional Wellbeing Index" },
  { key: "financial_situation", label: "Financial Situation Index" }
];

let weights = {};
DIMENSIONS.forEach(dim => { weights[dim.key] = 5; });

let DATASETS = {};
let currentGrouping = "Region";
let CURRENT_DATA = [];

const svg = d3.select("#viz");
const WIDTH = 1400;
const HEIGHT = 700;
const PAD_TOP = 40;
const PAD_BOTTOM = 80;
const PAD_LEFT = 20;
const PAD_RIGHT = 20;

const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

function randomScore() {
  return +(Math.random() * 6 + 2).toFixed(2); // 2-8 range
}

function generateTestData() {
  DATASETS.Region = [
    'Алматы', 'Астана', 'Шымкент', 'Акмолинская обл.', 'Актюбинская обл.',
    'Алматинская обл.', 'Атырауская обл.', 'ВКО', 'Жамбылская обл.',
    'ЗКО', 'Карагандинская обл.', 'Костанайская обл.', 'Кызылординская обл.',
    'Мангистауская обл.', 'Павлодарская обл.', 'СКО', 'Туркестанская обл.'
  ].map((name, i) => {
    const dims = {};
    DIMENSIONS.forEach(dim => { dims[dim.key] = randomScore(); });
    return {
      id: 'Region_' + i,
      name,
      shortName: name.length > 15 ? name.slice(0, 13) + '…' : name,
      dims,
      satisfaction: +(Math.random() * 3 + 5).toFixed(2),
      overallScore: 0
    };
  });

  DATASETS.AgeGroup = ['18-24', '25-34', '35-44', '45-54', '55-64', '65+'].map((name, i) => {
    const dims = {};
    DIMENSIONS.forEach(dim => { dims[dim.key] = randomScore(); });
    return {
      id: 'AgeGroup_' + i,
      name,
      shortName: name,
      dims,
      satisfaction: +(Math.random() * 3 + 5).toFixed(2),
      overallScore: 0
    };
  });

  DATASETS.Gender = ['Мужчины', 'Женщины'].map((name, i) => {
    const dims = {};
    DIMENSIONS.forEach(dim => { dims[dim.key] = randomScore(); });
    return {
      id: 'Gender_' + i,
      name,
      shortName: name,
      dims,
      satisfaction: +(Math.random() * 3 + 5).toFixed(2),
      overallScore: 0
    };
  });

  DATASETS.SettlementType = ['Город', 'Село'].map((name, i) => {
    const dims = {};
    DIMENSIONS.forEach(dim => { dims[dim.key] = randomScore(); });
    return {
      id: 'SettlementType_' + i,
      name,
      shortName: name,
      dims,
      satisfaction: +(Math.random() * 3 + 5).toFixed(2),
      overallScore: 0
    };
  });

  DATASETS.Year = ['2019', '2020', '2021', '2022', '2023', '2024'].map((name, i) => {
    const dims = {};
    DIMENSIONS.forEach(dim => { dims[dim.key] = randomScore(); });
    return {
      id: 'Year_' + i,
      name,
      shortName: name,
      dims,
      satisfaction: +(Math.random() * 3 + 5).toFixed(2),
      overallScore: 0
    };
  });
}

function updateViewTitle() {
  const map = {
    Region: 'Сравнение регионов Казахстана',
    AgeGroup: 'Сравнение возрастных групп',
    Gender: 'Сравнение по полу',
    SettlementType: 'Сравнение типов поселения',
    Year: 'Динамика по годам'
  };
  document.getElementById('viewTitle').textContent = map[currentGrouping] || 'Сравнение';
}

function overallScore(item) {
  let num = 0, den = 0;
  DIMENSIONS.forEach(dim => {
    const w = weights[dim.key];
    const s = item.dims[dim.key];
    if (s != null && !isNaN(s)) {
      num += s * w;
      den += w;
    }
  });
  return den === 0 ? 0 : +(num / den).toFixed(2);
}

function radiusFor(dimKey, item) {
  const raw = item.dims[dimKey];
  const w = weights[dimKey];
  const eff = (raw * w) / 10;
  const PETAL_BASE_RADIUS = 74; // increased from 24 to 74 (+50px)
  return (eff / 10) * (PETAL_BASE_RADIUS * 2.0);
}

function petalPolygon(dimIndex, r) {
  const total = DIMENSIONS.length;
  const ANGLE_SPREAD = 0.30;
  const angleCenter = (2 * Math.PI * dimIndex) / total - Math.PI / 2;
  const a1 = angleCenter - ANGLE_SPREAD;
  const a2 = angleCenter + ANGLE_SPREAD;
  const rTip = r;
  const rSide = r * 0.45;
  return [
    [0, 0],
    [Math.cos(a1) * rSide, Math.sin(a1) * rSide],
    [Math.cos(angleCenter) * rTip, Math.sin(angleCenter) * rTip],
    [Math.cos(a2) * rSide, Math.sin(a2) * rSide],
    [0, 0]
  ];
}

function sortData(arr) {
  const mode = document.getElementById("sortSelect").value;
  if (mode === "name") {
    arr.sort((a, b) => d3.ascending(a.name, b.name));
  } else if (mode === "score_desc") {
    arr.sort((a, b) => d3.descending(a.overallScore, b.overallScore));
  } else if (mode === "score_asc") {
    arr.sort((a, b) => d3.ascending(a.overallScore, b.overallScore));
  }
  return arr;
}

function getXScale(data) {
  return d3.scalePoint()
    .domain(data.map(d => d.name))
    .range([PAD_LEFT, WIDTH - PAD_RIGHT])
    .padding(0.5);
}

function showDetailCard(item, clientX, clientY) {
  const card = document.getElementById('detailCard');
  card.style.display = 'block';
  
  let html = `<div class="detail-header">${item.name}</div>`;
  html += `<div class="scale-row">`;
  for (let i = 0; i <= 10; i++) {
    html += `<span>${i}</span>`;
  }
  html += `</div>`;
  
  DIMENSIONS.forEach((dim, i) => {
    const val = item.dims[dim.key] || 0;
    const pct = (val / 10) * 100;
    const col = colorScale(i);
    html += `<div class="bar-row">
      <div class="bar-label">${dim.label}</div>
      <div class="bar-wrapper">
        <div class="bar-track">
          <div class="bar-fill" style="width:${pct}%;background:${col};"></div>
        </div>
        <div class="bar-value">${val.toFixed(1)}</div>
      </div>
    </div>`;
  });
  
  html += `<div class="detail-extra">`;
  html += `<strong>Взвешенный индекс:</strong> ${item.overallScore.toFixed(2)}<br>`;
  if (item.satisfaction != null) {
    html += `<strong>Удовлетворённость жизнью:</strong> ${item.satisfaction.toFixed(2)} / 10`;
  }
  html += `</div>`;
  
  card.innerHTML = html;
  
  // Show the card first with visibility hidden to get correct measurements
  card.style.visibility = 'hidden';
  card.style.display = 'block';
  
  const rect = card.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  
  // Determine if we should show the card on the left or right of the cursor
  let left = clientX + 15;
  if (left + rect.width > viewportWidth - 20) {
    left = clientX - rect.width - 15;
  }
  
  // Calculate vertical position
  let top = clientY - (rect.height / 2);
  // Ensure the card stays within the viewport vertically
  if (top < 20) {
    top = 20;
  } else if (top + rect.height > viewportHeight - 20) {
    top = viewportHeight - rect.height - 20;
  }
  
  // Apply the position and make visible
  card.style.left = left + 'px';
  card.style.top = top + 'px';
  card.style.visibility = 'visible';
}

function hideDetailCard() {
  document.getElementById('detailCard').style.display = 'none';
}

function updateAll() {
  CURRENT_DATA.forEach(d => { d.overallScore = overallScore(d); });
  sortData(CURRENT_DATA);

  const scores = CURRENT_DATA.map(d => d.overallScore || 0);
  const minS = d3.min(scores) || 0;
  const maxS = d3.max(scores) || 10;
  const yMin = Math.max(0, minS - 0.5);
  const yMax = Math.min(10, maxS + 0.5);
  const yLocal = d3.scaleLinear().domain([yMin, yMax]).range([HEIGHT - PAD_BOTTOM, PAD_TOP]);

  const xScale = getXScale(CURRENT_DATA);

  const stems = svg.selectAll(".stem-group").data(CURRENT_DATA, d => d.id);

  const stemsEnter = stems.enter().append("g").attr("class", "stem-group");
  stemsEnter.append("line").attr("class", "axis-line stem-line");
  stemsEnter.append("text").attr("class", "stem-label").attr("transform", "rotate(-90)");
  stemsEnter.append("g").attr("class", "flower-group");

  const stemsMerge = stemsEnter.merge(stems);

  stemsMerge.select(".stem-line")
    .attr("x1", d => xScale(d.name))
    .attr("x2", d => xScale(d.name))
    .attr("y1", PAD_TOP)
    .attr("y2", HEIGHT - PAD_BOTTOM);

  stemsMerge.select(".stem-label")
    .text(d => d.shortName || d.name)
    .attr("x", d => -(HEIGHT - PAD_BOTTOM - 10))
    .attr("y", d => xScale(d.name));

  stemsMerge.each(function(item) {
    const gFlower = d3.select(this).select(".flower-group");
    const fx = xScale(item.name);
    const fy = yLocal(item.overallScore);

    gFlower.transition().duration(200).attr("transform", `translate(${fx},${fy})`);

    const petals = gFlower.selectAll(".petal").data(
      DIMENSIONS.map((dim, i) => ({
        color: colorScale(i),
        poly: petalPolygon(i, radiusFor(dim.key, item))
      })),
      (d, i) => i
    );

    petals.enter()
      .append("path")
      .attr("class", "petal")
      .attr("fill", d => d.color)
      .merge(petals)
      .transition()
      .duration(200)
      .attr("d", d => d3.line()(d.poly));

    petals.exit().remove();

    const scoreText = gFlower.selectAll(".score-text").data([item]);
    scoreText.enter()
      .append("text")
      .attr("class", "score-text")
      .merge(scoreText)
      .text(d => d.overallScore.toFixed(2));

    const HIT_RADIUS = 50; // Increased hit area for better interaction
    const hitArea = gFlower.selectAll(".hit-area").data([item]);
    hitArea.enter()
      .append("circle")
      .attr("class", "hit-area")
      .attr("r", HIT_RADIUS)
      .merge(hitArea)
      .on("mousemove", (event) => {
        // Prevent any text selection during hover
        event.preventDefault();
        
        // Update visual states
        svg.selectAll(".flower-group").classed("highlight", false).style("opacity", 0.15);
        gFlower.classed("highlight", true).style("opacity", 1);
        
        // Get correct mouse coordinates
        const mouseX = event.clientX;
        const mouseY = event.clientY;
        
        // Show detail card with slight delay to prevent flickering
        clearTimeout(window._detailCardTimeout);
        window._detailCardTimeout = setTimeout(() => {
          showDetailCard(item, mouseX, mouseY);
        }, 50);
      })
      .on("mouseleave", () => {
        clearTimeout(window._detailCardTimeout);
        svg.selectAll(".flower-group").classed("highlight", false).style("opacity", 1);
        hideDetailCard();
      });
  });

  stems.exit().remove();
}

function initControls() {
  const slidersContainer = d3.select("#sliders");
  const sliderGroups = slidersContainer.selectAll(".slider-block")
    .data(DIMENSIONS)
    .enter()
    .append("div")
    .attr("class", "slider-block");

  const headerRow = sliderGroups.append("div").attr("class", "slider-head");
  headerRow.append("div").text(d => d.label);
  headerRow.append("div").attr("class", "val").text(d => weights[d.key]);

  sliderGroups.append("div")
    .attr("class", "slider-desc")
    .text("Вес показателя (0–10)");

  sliderGroups.append("input")
    .attr("type", "range")
    .attr("min", 0)
    .attr("max", 10)
    .attr("step", 1)
    .attr("value", d => weights[d.key])
    .on("input", function(event, d) {
      weights[d.key] = +this.value;
      d3.select(this.parentNode).select(".slider-head .val").text(this.value);
      updateAll();
    });

  document.getElementById("groupSelect").addEventListener("change", (e) => {
    currentGrouping = e.target.value;
    CURRENT_DATA = DATASETS[currentGrouping] || [];
    updateViewTitle();
    updateAll();
  });

  document.getElementById("sortSelect").addEventListener("change", updateAll);
}

function boot() {
  generateTestData();
  initControls();
  currentGrouping = 'Region';
  CURRENT_DATA = DATASETS[currentGrouping] || [];
  updateViewTitle();
  updateAll();
}

boot();
</script>
</body>
</html>